{
    "glslVersion": "300 es",
    "uniforms": {
        "u_worldMatrix": {
            "value": {
                "elements": [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ]
            }
        },
        "u_viewProjectionMatrix": {
            "value": {
                "elements": [
                    0.5080542826196012,
                    0.05698587091620866,
                    -0.907347980553538,
                    -0.9064410860202512,
                    6.279559650234313e-18,
                    1.7309109889938097,
                    0.036309091501778135,
                    0.03627280055574937,
                    -1.0944682170727829,
                    0.026452952508041878,
                    -0.42119270359389166,
                    -0.42077172138140406,
                    -0.04271468207748368,
                    -1.8089224233140264,
                    3.4983134282391233,
                    3.5947668880809633
                ]
            }
        },
        "u_worldInverseTransposeMatrix": {
            "value": {
                "elements": [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ]
            }
        },
        "type": {},
        "direction": {
            "value": [
                0,
                0,
                0
            ]
        },
        "color": {
            "value": [
                0,
                0,
                0
            ]
        },
        "intensity": {},
        "base": {
            "value": 0.5
        },
        "base_color": {
            "value": {
                "0": 0.10377919673919678,
                "1": 0.5921202898025513,
                "2": 0.850649356842041
            }
        },
        "diffuse_roughness": {
            "value": 0
        },
        "metalness": {
            "value": 0
        },
        "specular": {
            "value": 1
        },
        "specular_color": {
            "value": {
                "0": 1,
                "1": 1,
                "2": 1
            }
        },
        "specular_roughness": {
            "value": 0.4000000059604645
        },
        "specular_IOR": {
            "value": 1.5
        },
        "specular_anisotropy": {
            "value": 0.5
        },
        "specular_rotation": {
            "value": 0
        },
        "transmission": {
            "value": 0
        },
        "transmission_color": {
            "value": {
                "0": 1,
                "1": 1,
                "2": 1
            }
        },
        "transmission_depth": {
            "value": 0
        },
        "transmission_scatter": {
            "value": {
                "0": 0,
                "1": 0,
                "2": 0
            }
        },
        "transmission_scatter_anisotropy": {
            "value": 0
        },
        "transmission_dispersion": {
            "value": 0
        },
        "transmission_extra_roughness": {
            "value": 0
        },
        "subsurface": {
            "value": 0
        },
        "subsurface_color": {
            "value": {
                "0": 1,
                "1": 1,
                "2": 1
            }
        },
        "subsurface_radius": {
            "value": {
                "0": 1,
                "1": 1,
                "2": 1
            }
        },
        "subsurface_scale": {
            "value": 1
        },
        "subsurface_anisotropy": {
            "value": 0
        },
        "sheen": {
            "value": 0
        },
        "sheen_color": {
            "value": {
                "0": 1,
                "1": 1,
                "2": 1
            }
        },
        "sheen_roughness": {
            "value": 0.30000001192092896
        },
        "coat": {
            "value": 1
        },
        "coat_color": {
            "value": {
                "0": 1,
                "1": 1,
                "2": 1
            }
        },
        "coat_roughness": {
            "value": 0
        },
        "coat_anisotropy": {
            "value": 0
        },
        "coat_rotation": {
            "value": 0
        },
        "coat_IOR": {
            "value": 1.5
        },
        "coat_affect_color": {
            "value": 0
        },
        "coat_affect_roughness": {
            "value": 0
        },
        "thin_film_thickness": {
            "value": 0
        },
        "thin_film_IOR": {
            "value": 1.5
        },
        "emission": {
            "value": 0
        },
        "emission_color": {
            "value": {
                "0": 1,
                "1": 1,
                "2": 1
            }
        },
        "opacity": {
            "value": {
                "0": 1,
                "1": 1,
                "2": 1
            }
        },
        "thin_walled": {
            "value": false
        },
        "u_envMatrix": {
            "value": {
                "elements": [
                    6.123233995736766e-17,
                    0,
                    -1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    6.123233995736766e-17,
                    0,
                    0,
                    0,
                    0,
                    1
                ]
            }
        },
        "u_envRadiance": {
            "value": {
                "metadata": {
                    "version": 4.5,
                    "type": "Texture",
                    "generator": "Texture.toJSON"
                },
                "uuid": "eaa9035c-8ab4-4a10-8b6e-5309ec2316ef",
                "name": "",
                "image": "77c5fa5d-afd7-4965-8c89-44be00071a5b",
                "mapping": 300,
                "channel": 0,
                "repeat": [
                    1,
                    1
                ],
                "offset": [
                    0,
                    0
                ],
                "center": [
                    0,
                    0
                ],
                "rotation": 0,
                "wrap": [
                    1000,
                    1001
                ],
                "format": 1023,
                "internalFormat": null,
                "type": 1016,
                "colorSpace": "",
                "minFilter": 1008,
                "magFilter": 1006,
                "anisotropy": 16,
                "flipY": false,
                "generateMipmaps": true,
                "premultiplyAlpha": false,
                "unpackAlignment": 1
            }
        },
        "u_envLightIntensity": {
            "value": 1
        },
        "u_envRadianceMips": {
            "value": 12
        },
        "u_envRadianceSamples": {
            "value": 16
        },
        "u_envIrradiance": {
            "value": {
                "metadata": {
                    "version": 4.5,
                    "type": "Texture",
                    "generator": "Texture.toJSON"
                },
                "uuid": "d362518f-7bfd-4569-9c8a-02c85f55630e",
                "name": "",
                "image": "1f06d62f-0928-4ef9-a3b3-6a6493cb5854",
                "mapping": 300,
                "channel": 0,
                "repeat": [
                    1,
                    1
                ],
                "offset": [
                    0,
                    0
                ],
                "center": [
                    0,
                    0
                ],
                "rotation": 0,
                "wrap": [
                    1000,
                    1001
                ],
                "format": 1023,
                "internalFormat": null,
                "type": 1016,
                "colorSpace": "",
                "minFilter": 1008,
                "magFilter": 1006,
                "anisotropy": 16,
                "flipY": false,
                "generateMipmaps": true,
                "premultiplyAlpha": false,
                "unpackAlignment": 1
            }
        },
        "u_refractionTwoSided": {},
        "u_viewPosition": {
            "value": {
                "x": 3.3077104070542114,
                "y": 0.9133023045414139,
                "z": 1.4964178313667003
            }
        },
        "u_numActiveLightSources": {
            "value": 1
        },
        "u_lightData": {
            "value": [
                {
                    "type": 1,
                    "direction": {
                        "x": -0.7112688926164376,
                        "y": -0.4790139227525348,
                        "z": -0.5144338871083584
                    },
                    "color": {
                        "x": 1,
                        "y": 0.8944740295410156,
                        "z": 0.5672339797019958
                    },
                    "intensity": 2.5277600288391113
                }
            ]
        },
        "u_refractionEnv": {
            "value": true
        }
    },
    "vertexShader": "precision mediump float;\n\n// Uniform block: PrivateUniforms\nuniform mat4 u_worldMatrix;\nuniform mat4 u_viewProjectionMatrix;\nuniform mat4 u_worldInverseTransposeMatrix;\n\n// Inputs block: VertexInputs\nin vec3 i_position;\nin vec3 i_normal;\nin vec3 i_tangent;\n\nout vec3 normalWorld;\nout vec3 tangentWorld;\nout vec3 positionWorld;\n\nvoid main()\n{\n    vec4 hPositionWorld = u_worldMatrix * vec4(i_position, 1.0);\n    gl_Position = u_viewProjectionMatrix * hPositionWorld;\n    normalWorld = normalize((u_worldInverseTransposeMatrix * vec4(i_normal, 0.0)).xyz);\n    tangentWorld = normalize((u_worldMatrix * vec4(i_tangent, 0.0)).xyz);\n    positionWorld = hPositionWorld.xyz;\n}\n\n",
    "fragmentShader": "precision mediump float;\n\nstruct BSDF { vec3 response; vec3 throughput; };\n#define EDF vec3\nstruct surfaceshader { vec3 color; vec3 transparency; };\nstruct volumeshader { vec3 color; vec3 transparency; };\nstruct displacementshader { vec3 offset; float scale; };\nstruct lightshader { vec3 intensity; vec3 direction; };\n#define material surfaceshader\n\n// Uniform block: PublicUniforms\nuniform float base;\nuniform vec3 base_color;\nuniform float diffuse_roughness;\nuniform float metalness;\nuniform float specular;\nuniform vec3 specular_color;\nuniform float specular_roughness;\nuniform float specular_IOR;\nuniform float specular_anisotropy;\nuniform float specular_rotation;\nuniform float transmission;\nuniform vec3 transmission_color;\nuniform float transmission_depth;\nuniform vec3 transmission_scatter;\nuniform float transmission_scatter_anisotropy;\nuniform float transmission_dispersion;\nuniform float transmission_extra_roughness;\nuniform float subsurface;\nuniform vec3 subsurface_color;\nuniform vec3 subsurface_radius;\nuniform float subsurface_scale;\nuniform float subsurface_anisotropy;\nuniform float sheen;\nuniform vec3 sheen_color;\nuniform float sheen_roughness;\nuniform float coat;\nuniform vec3 coat_color;\nuniform float coat_roughness;\nuniform float coat_anisotropy;\nuniform float coat_rotation;\nuniform float coat_IOR;\nuniform float coat_affect_color;\nuniform float coat_affect_roughness;\nuniform float thin_film_thickness;\nuniform float thin_film_IOR;\nuniform float emission;\nuniform vec3 emission_color;\nuniform vec3 opacity;\nuniform bool thin_walled;\n\n// Uniform block: PrivateUniforms\nuniform mat4 u_envMatrix;\nuniform sampler2D u_envRadiance;\nuniform float u_envLightIntensity;\nuniform int u_envRadianceMips;\nuniform int u_envRadianceSamples;\nuniform sampler2D u_envIrradiance;\nuniform bool u_refractionTwoSided;\nuniform vec3 u_viewPosition;\nuniform int u_numActiveLightSources;\n\nin vec3 normalWorld;\nin vec3 tangentWorld;\nin vec3 positionWorld;\n\n// Pixel shader outputs\nout vec4 out1;\n\n#define M_FLOAT_EPS 1e-8\n\n#define mx_mod mod\n#define mx_inverse inverse\n#define mx_inversesqrt inversesqrt\n#define mx_sin sin\n#define mx_cos cos\n#define mx_tan tan\n#define mx_asin asin\n#define mx_acos acos\n#define mx_atan atan\n#define mx_radians radians\n\nfloat mx_square(float x)\n{\n    return x*x;\n}\n\nvec2 mx_square(vec2 x)\n{\n    return x*x;\n}\n\nvec3 mx_square(vec3 x)\n{\n    return x*x;\n}\n\nvec3 mx_srgb_encode(vec3 color)\n{\n    bvec3 isAbove = greaterThan(color, vec3(0.0031308));\n    vec3 linSeg = color * 12.92;\n    vec3 powSeg = 1.055 * pow(max(color, vec3(0.0)), vec3(1.0 / 2.4)) - 0.055;\n    return mix(linSeg, powSeg, isAbove);\n}\n\n#define DIRECTIONAL_ALBEDO_METHOD 0\n\n#define MAX_LIGHT_SOURCES 1\n#define M_PI 3.1415926535897932\n#define M_PI_INV (1.0 / M_PI)\n\nfloat mx_pow5(float x)\n{\n    return mx_square(mx_square(x)) * x;\n}\n\nfloat mx_pow6(float x)\n{\n    float x2 = mx_square(x);\n    return mx_square(x2) * x2;\n}\n\n// Standard Schlick Fresnel\nfloat mx_fresnel_schlick(float cosTheta, float F0)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x5 = mx_pow5(x);\n    return F0 + (1.0 - F0) * x5;\n}\nvec3 mx_fresnel_schlick(float cosTheta, vec3 F0)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x5 = mx_pow5(x);\n    return F0 + (1.0 - F0) * x5;\n}\n\n// Generalized Schlick Fresnel\nfloat mx_fresnel_schlick(float cosTheta, float F0, float F90)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x5 = mx_pow5(x);\n    return mix(F0, F90, x5);\n}\nvec3 mx_fresnel_schlick(float cosTheta, vec3 F0, vec3 F90)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    float x5 = mx_pow5(x);\n    return mix(F0, F90, x5);\n}\n\n// Generalized Schlick Fresnel with a variable exponent\nfloat mx_fresnel_schlick(float cosTheta, float F0, float F90, float exponent)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    return mix(F0, F90, pow(x, exponent));\n}\nvec3 mx_fresnel_schlick(float cosTheta, vec3 F0, vec3 F90, float exponent)\n{\n    float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n    return mix(F0, F90, pow(x, exponent));\n}\n\n// Enforce that the given normal is forward-facing from the specified view direction.\nvec3 mx_forward_facing_normal(vec3 N, vec3 V)\n{\n    return (dot(N, V) < 0.0) ? -N : N;\n}\n\n// https://www.graphics.rwth-aachen.de/publication/2/jgt.pdf\nfloat mx_golden_ratio_sequence(int i)\n{\n    const float GOLDEN_RATIO = 1.6180339887498948;\n    return fract((float(i) + 1.0) * GOLDEN_RATIO);\n}\n\n// https://people.irisa.fr/Ricardo.Marques/articles/2013/SF_CGF.pdf\nvec2 mx_spherical_fibonacci(int i, int numSamples)\n{\n    return vec2((float(i) + 0.5) / float(numSamples), mx_golden_ratio_sequence(i));\n}\n\n// Generate a uniform-weighted sample on the unit hemisphere.\nvec3 mx_uniform_sample_hemisphere(vec2 Xi)\n{\n    float phi = 2.0 * M_PI * Xi.x;\n    float cosTheta = 1.0 - Xi.y;\n    float sinTheta = sqrt(1.0 - mx_square(cosTheta));\n    return vec3(mx_cos(phi) * sinTheta,\n                mx_sin(phi) * sinTheta,\n                cosTheta);\n}\n\n// Generate a cosine-weighted sample on the unit hemisphere.\nvec3 mx_cosine_sample_hemisphere(vec2 Xi)\n{\n    float phi = 2.0 * M_PI * Xi.x;\n    float cosTheta = sqrt(Xi.y);\n    float sinTheta = sqrt(1.0 - Xi.y);\n    return vec3(mx_cos(phi) * sinTheta,\n                mx_sin(phi) * sinTheta,\n                cosTheta);\n}\n\n// Construct an orthonormal basis from a unit vector.\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nmat3 mx_orthonormal_basis(vec3 N)\n{\n    float sign = (N.z < 0.0) ? -1.0 : 1.0;\n    float a = -1.0 / (sign + N.z);\n    float b = N.x * N.y * a;\n    vec3 X = vec3(1.0 + sign * N.x * N.x * a, sign * b, -sign * N.x);\n    vec3 Y = vec3(b, sign + N.y * N.y * a, -N.y);\n    return mat3(X, Y, N);\n}\n\nconst int FRESNEL_MODEL_DIELECTRIC = 0;\nconst int FRESNEL_MODEL_CONDUCTOR = 1;\nconst int FRESNEL_MODEL_SCHLICK = 2;\n\n// Parameters for Fresnel calculations\nstruct FresnelData\n{\n    // Fresnel model\n    int model;\n    bool airy;\n\n    // Physical Fresnel\n    vec3 ior;\n    vec3 extinction;\n\n    // Generalized Schlick Fresnel\n    vec3 F0;\n    vec3 F82;\n    vec3 F90;\n    float exponent;\n\n    // Thin film\n    float tf_thickness;\n    float tf_ior;\n\n    // Refraction\n    bool refraction;\n};\n\n// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf\n// Appendix B.2 Equation 13\nfloat mx_ggx_NDF(vec3 H, vec2 alpha)\n{\n    vec2 He = H.xy / alpha;\n    float denom = dot(He, He) + mx_square(H.z);\n    return 1.0 / (M_PI * alpha.x * alpha.y * mx_square(denom));\n}\n\n// https://ggx-research.github.io/publication/2023/06/09/publication-ggx.html\nvec3 mx_ggx_importance_sample_VNDF(vec2 Xi, vec3 V, vec2 alpha)\n{\n    // Transform the view direction to the hemisphere configuration.\n    V = normalize(vec3(V.xy * alpha, V.z));\n\n    // Sample a spherical cap in (-V.z, 1].\n    float phi = 2.0 * M_PI * Xi.x;\n    float z = (1.0 - Xi.y) * (1.0 + V.z) - V.z;\n    float sinTheta = sqrt(clamp(1.0 - z * z, 0.0, 1.0));\n    float x = sinTheta * mx_cos(phi);\n    float y = sinTheta * mx_sin(phi);\n    vec3 c = vec3(x, y, z);\n\n    // Compute the microfacet normal.\n    vec3 H = c + V;\n\n    // Transform the microfacet normal back to the ellipsoid configuration.\n    H = normalize(vec3(H.xy * alpha, max(H.z, 0.0)));\n\n    return H;\n}\n\n// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n// Equation 34\nfloat mx_ggx_smith_G1(float cosTheta, float alpha)\n{\n    float cosTheta2 = mx_square(cosTheta);\n    float tanTheta2 = (1.0 - cosTheta2) / cosTheta2;\n    return 2.0 / (1.0 + sqrt(1.0 + mx_square(alpha) * tanTheta2));\n}\n\n// Height-correlated Smith masking-shadowing\n// http://jcgt.org/published/0003/02/03/paper.pdf\n// Equations 72 and 99\nfloat mx_ggx_smith_G2(float NdotL, float NdotV, float alpha)\n{\n    float alpha2 = mx_square(alpha);\n    float lambdaL = sqrt(alpha2 + (1.0 - alpha2) * mx_square(NdotL));\n    float lambdaV = sqrt(alpha2 + (1.0 - alpha2) * mx_square(NdotV));\n    return 2.0 / (lambdaL / NdotL + lambdaV / NdotV);\n}\n\n// Rational quadratic fit to Monte Carlo data for GGX directional albedo.\nvec3 mx_ggx_dir_albedo_analytic(float NdotV, float alpha, vec3 F0, vec3 F90)\n{\n    float x = NdotV;\n    float y = alpha;\n    float x2 = mx_square(x);\n    float y2 = mx_square(y);\n    vec4 r = vec4(0.1003, 0.9345, 1.0, 1.0) +\n             vec4(-0.6303, -2.323, -1.765, 0.2281) * x +\n             vec4(9.748, 2.229, 8.263, 15.94) * y +\n             vec4(-2.038, -3.748, 11.53, -55.83) * x * y +\n             vec4(29.34, 1.424, 28.96, 13.08) * x2 +\n             vec4(-8.245, -0.7684, -7.507, 41.26) * y2 +\n             vec4(-26.44, 1.436, -36.11, 54.9) * x2 * y +\n             vec4(19.99, 0.2913, 15.86, 300.2) * x * y2 +\n             vec4(-5.448, 0.6286, 33.37, -285.1) * x2 * y2;\n    vec2 AB = clamp(r.xy / r.zw, 0.0, 1.0);\n    return F0 * AB.x + F90 * AB.y;\n}\n\nvec3 mx_ggx_dir_albedo_table_lookup(float NdotV, float alpha, vec3 F0, vec3 F90)\n{\n#if DIRECTIONAL_ALBEDO_METHOD == 1\n    if (textureSize(u_albedoTable, 0).x > 1)\n    {\n        vec2 AB = texture(u_albedoTable, vec2(NdotV, alpha)).rg;\n        return F0 * AB.x + F90 * AB.y;\n    }\n#endif\n    return vec3(0.0);\n}\n\n// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\nvec3 mx_ggx_dir_albedo_monte_carlo(float NdotV, float alpha, vec3 F0, vec3 F90)\n{\n    NdotV = clamp(NdotV, M_FLOAT_EPS, 1.0);\n    vec3 V = vec3(sqrt(1.0 - mx_square(NdotV)), 0, NdotV);\n\n    vec2 AB = vec2(0.0);\n    const int SAMPLE_COUNT = 64;\n    for (int i = 0; i < SAMPLE_COUNT; i++)\n    {\n        vec2 Xi = mx_spherical_fibonacci(i, SAMPLE_COUNT);\n\n        // Compute the half vector and incoming light direction.\n        vec3 H = mx_ggx_importance_sample_VNDF(Xi, V, vec2(alpha));\n        vec3 L = -reflect(V, H);\n        \n        // Compute dot products for this sample.\n        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);\n        float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);\n\n        // Compute the Fresnel term.\n        float Fc = mx_fresnel_schlick(VdotH, 0.0, 1.0);\n\n        // Compute the per-sample geometric term.\n        // https://hal.inria.fr/hal-00996995v2/document, Algorithm 2\n        float G2 = mx_ggx_smith_G2(NdotL, NdotV, alpha);\n        \n        // Add the contribution of this sample.\n        AB += vec2(G2 * (1.0 - Fc), G2 * Fc);\n    }\n\n    // Apply the global component of the geometric term and normalize.\n    AB /= mx_ggx_smith_G1(NdotV, alpha) * float(SAMPLE_COUNT);\n\n    // Return the final directional albedo.\n    return F0 * AB.x + F90 * AB.y;\n}\n\nvec3 mx_ggx_dir_albedo(float NdotV, float alpha, vec3 F0, vec3 F90)\n{\n#if DIRECTIONAL_ALBEDO_METHOD == 0\n    return mx_ggx_dir_albedo_analytic(NdotV, alpha, F0, F90);\n#elif DIRECTIONAL_ALBEDO_METHOD == 1\n    return mx_ggx_dir_albedo_table_lookup(NdotV, alpha, F0, F90);\n#else\n    return mx_ggx_dir_albedo_monte_carlo(NdotV, alpha, F0, F90);\n#endif\n}\n\nfloat mx_ggx_dir_albedo(float NdotV, float alpha, float F0, float F90)\n{\n    return mx_ggx_dir_albedo(NdotV, alpha, vec3(F0), vec3(F90)).x;\n}\n\n// https://blog.selfshadow.com/publications/turquin/ms_comp_final.pdf\n// Equations 14 and 16\nvec3 mx_ggx_energy_compensation(float NdotV, float alpha, vec3 Fss)\n{\n    float Ess = mx_ggx_dir_albedo(NdotV, alpha, 1.0, 1.0);\n    return 1.0 + Fss * (1.0 - Ess) / Ess;\n}\n\nfloat mx_ggx_energy_compensation(float NdotV, float alpha, float Fss)\n{\n    return mx_ggx_energy_compensation(NdotV, alpha, vec3(Fss)).x;\n}\n\n// Compute the average of an anisotropic alpha pair.\nfloat mx_average_alpha(vec2 alpha)\n{\n    return sqrt(alpha.x * alpha.y);\n}\n\n// Convert a real-valued index of refraction to normal-incidence reflectivity.\nfloat mx_ior_to_f0(float ior)\n{\n    return mx_square((ior - 1.0) / (ior + 1.0));\n}\n\n// Convert normal-incidence reflectivity to real-valued index of refraction.\nfloat mx_f0_to_ior(float F0)\n{\n    float sqrtF0 = sqrt(clamp(F0, 0.01, 0.99));\n    return (1.0 + sqrtF0) / (1.0 - sqrtF0);\n}\nvec3 mx_f0_to_ior(vec3 F0)\n{\n    vec3 sqrtF0 = sqrt(clamp(F0, 0.01, 0.99));\n    return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\n\n// https://renderwonk.com/publications/wp-generalization-adobe/gen-adobe.pdf\nvec3 mx_fresnel_hoffman_schlick(float cosTheta, FresnelData fd)\n{\n    const float COS_THETA_MAX = 1.0 / 7.0;\n    const float COS_THETA_FACTOR = 1.0 / (COS_THETA_MAX * pow(1.0 - COS_THETA_MAX, 6.0));\n\n    float x = clamp(cosTheta, 0.0, 1.0);\n    vec3 a = mix(fd.F0, fd.F90, pow(1.0 - COS_THETA_MAX, fd.exponent)) * (vec3(1.0) - fd.F82) * COS_THETA_FACTOR;\n    return mix(fd.F0, fd.F90, pow(1.0 - x, fd.exponent)) - a * x * mx_pow6(1.0 - x);\n}\n\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nfloat mx_fresnel_dielectric(float cosTheta, float ior)\n{\n    float c = cosTheta;\n    float g2 = ior*ior + c*c - 1.0;\n    if (g2 < 0.0)\n    {\n        // Total internal reflection\n        return 1.0;\n    }\n\n    float g = sqrt(g2);\n    return 0.5 * mx_square((g - c) / (g + c)) *\n                (1.0 + mx_square(((g + c) * c - 1.0) / ((g - c) * c + 1.0)));\n}\n\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nvec2 mx_fresnel_dielectric_polarized(float cosTheta, float ior)\n{\n    float cosTheta2 = mx_square(clamp(cosTheta, 0.0, 1.0));\n    float sinTheta2 = 1.0 - cosTheta2;\n\n    float t0 = max(ior * ior - sinTheta2, 0.0);\n    float t1 = t0 + cosTheta2;\n    float t2 = 2.0 * sqrt(t0) * cosTheta;\n    float Rs = (t1 - t2) / (t1 + t2);\n\n    float t3 = cosTheta2 * t0 + sinTheta2 * sinTheta2;\n    float t4 = t2 * sinTheta2;\n    float Rp = Rs * (t3 - t4) / (t3 + t4);\n\n    return vec2(Rp, Rs);\n}\n\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nvoid mx_fresnel_conductor_polarized(float cosTheta, vec3 n, vec3 k, out vec3 Rp, out vec3 Rs)\n{\n    float cosTheta2 = mx_square(clamp(cosTheta, 0.0, 1.0));\n    float sinTheta2 = 1.0 - cosTheta2;\n    vec3 n2 = n * n;\n    vec3 k2 = k * k;\n\n    vec3 t0 = n2 - k2 - vec3(sinTheta2);\n    vec3 a2plusb2 = sqrt(t0 * t0 + 4.0 * n2 * k2);\n    vec3 t1 = a2plusb2 + vec3(cosTheta2);\n    vec3 a = sqrt(max(0.5 * (a2plusb2 + t0), 0.0));\n    vec3 t2 = 2.0 * a * cosTheta;\n    Rs = (t1 - t2) / (t1 + t2);\n\n    vec3 t3 = cosTheta2 * a2plusb2 + vec3(sinTheta2 * sinTheta2);\n    vec3 t4 = t2 * sinTheta2;\n    Rp = Rs * (t3 - t4) / (t3 + t4);\n}\n\nvec3 mx_fresnel_conductor(float cosTheta, vec3 n, vec3 k)\n{\n    vec3 Rp, Rs;\n    mx_fresnel_conductor_polarized(cosTheta, n, k, Rp, Rs);\n    return 0.5 * (Rp  + Rs);\n}\n\n// https://belcour.github.io/blog/research/publication/2017/05/01/brdf-thin-film.html\nvoid mx_fresnel_conductor_phase_polarized(float cosTheta, float eta1, vec3 eta2, vec3 kappa2, out vec3 phiP, out vec3 phiS)\n{\n    vec3 k2 = kappa2 / eta2;\n    vec3 sinThetaSqr = vec3(1.0) - cosTheta * cosTheta;\n    vec3 A = eta2*eta2*(vec3(1.0)-k2*k2) - eta1*eta1*sinThetaSqr;\n    vec3 B = sqrt(A*A + mx_square(2.0*eta2*eta2*k2));\n    vec3 U = sqrt((A+B)/2.0);\n    vec3 V = max(vec3(0.0), sqrt((B-A)/2.0));\n\n    phiS = mx_atan(2.0*eta1*V*cosTheta, U*U + V*V - mx_square(eta1*cosTheta));\n    phiP = mx_atan(2.0*eta1*eta2*eta2*cosTheta * (2.0*k2*U - (vec3(1.0)-k2*k2) * V),\n                   mx_square(eta2*eta2*(vec3(1.0)+k2*k2)*cosTheta) - eta1*eta1*(U*U+V*V));\n}\n\n// https://belcour.github.io/blog/research/publication/2017/05/01/brdf-thin-film.html\nvec3 mx_eval_sensitivity(float opd, vec3 shift)\n{\n    // Use Gaussian fits, given by 3 parameters: val, pos and var\n    float phase = 2.0*M_PI * opd;\n    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n    vec3 xyz = val * sqrt(2.0*M_PI * var) * mx_cos(pos * phase + shift) * exp(- var * phase*phase);\n    xyz.x   += 9.7470e-14 * sqrt(2.0*M_PI * 4.5282e+09) * mx_cos(2.2399e+06 * phase + shift[0]) * exp(- 4.5282e+09 * phase*phase);\n    return xyz / 1.0685e-7;\n}\n\n// A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence\n// https://belcour.github.io/blog/research/publication/2017/05/01/brdf-thin-film.html\nvec3 mx_fresnel_airy(float cosTheta, FresnelData fd)\n{\n    // XYZ to CIE 1931 RGB color space (using neutral E illuminant)\n    const mat3 XYZ_TO_RGB = mat3(2.3706743, -0.5138850, 0.0052982, -0.9000405, 1.4253036, -0.0146949, -0.4706338, 0.0885814, 1.0093968);\n\n    // Assume vacuum on the outside\n    float eta1 = 1.0;\n    float eta2 = max(fd.tf_ior, eta1);\n    vec3 eta3 = (fd.model == FRESNEL_MODEL_SCHLICK) ? mx_f0_to_ior(fd.F0) : fd.ior;\n    vec3 kappa3 = (fd.model == FRESNEL_MODEL_SCHLICK) ? vec3(0.0) : fd.extinction;\n    float cosThetaT = sqrt(1.0 - (1.0 - mx_square(cosTheta)) * mx_square(eta1 / eta2));\n\n    // First interface\n    vec2 R12 = mx_fresnel_dielectric_polarized(cosTheta, eta2 / eta1);\n    if (cosThetaT <= 0.0)\n    {\n        // Total internal reflection\n        R12 = vec2(1.0);\n    }\n    vec2 T121 = vec2(1.0) - R12;\n\n    // Second interface\n    vec3 R23p, R23s;\n    if (fd.model == FRESNEL_MODEL_SCHLICK)\n    {\n        vec3 f = mx_fresnel_hoffman_schlick(cosThetaT, fd);\n        R23p = 0.5 * f;\n        R23s = 0.5 * f;\n    }\n    else\n    {\n        mx_fresnel_conductor_polarized(cosThetaT, eta3 / eta2, kappa3 / eta2, R23p, R23s);\n    }\n\n    // Phase shift\n    float cosB = mx_cos(mx_atan(eta2 / eta1));\n    vec2 phi21 = vec2(cosTheta < cosB ? 0.0 : M_PI, M_PI);\n    vec3 phi23p, phi23s;\n    if (fd.model == FRESNEL_MODEL_SCHLICK)\n    {\n        phi23p = vec3((eta3[0] < eta2) ? M_PI : 0.0,\n                      (eta3[1] < eta2) ? M_PI : 0.0,\n                      (eta3[2] < eta2) ? M_PI : 0.0);\n        phi23s = phi23p;\n    }\n    else\n    {\n        mx_fresnel_conductor_phase_polarized(cosThetaT, eta2, eta3, kappa3, phi23p, phi23s);\n    }\n    vec3 r123p = max(sqrt(R12.x*R23p), 0.0);\n    vec3 r123s = max(sqrt(R12.y*R23s), 0.0);\n\n    // Iridescence term\n    vec3 I = vec3(0.0);\n    vec3 Cm, Sm;\n\n    // Optical path difference\n    float distMeters = fd.tf_thickness * 1.0e-9;\n    float opd = 2.0 * eta2 * cosThetaT * distMeters;\n\n    // Iridescence term using spectral antialiasing for Parallel polarization\n\n    // Reflectance term for m=0 (DC term amplitude)\n    vec3 Rs = (mx_square(T121.x) * R23p) / (vec3(1.0) - R12.x*R23p);\n    I += R12.x + Rs;\n\n    // Reflectance term for m>0 (pairs of diracs)\n    Cm = Rs - T121.x;\n    for (int m=1; m<=2; m++)\n    {\n        Cm *= r123p;\n        Sm  = 2.0 * mx_eval_sensitivity(float(m) * opd, float(m)*(phi23p+vec3(phi21.x)));\n        I  += Cm*Sm;\n    }\n\n    // Iridescence term using spectral antialiasing for Perpendicular polarization\n\n    // Reflectance term for m=0 (DC term amplitude)\n    vec3 Rp = (mx_square(T121.y) * R23s) / (vec3(1.0) - R12.y*R23s);\n    I += R12.y + Rp;\n\n    // Reflectance term for m>0 (pairs of diracs)\n    Cm = Rp - T121.y;\n    for (int m=1; m<=2; m++)\n    {\n        Cm *= r123s;\n        Sm  = 2.0 * mx_eval_sensitivity(float(m) * opd, float(m)*(phi23s+vec3(phi21.y)));\n        I  += Cm*Sm;\n    }\n\n    // Average parallel and perpendicular polarization\n    I *= 0.5;\n\n    // Convert back to RGB reflectance\n    I = clamp(XYZ_TO_RGB * I, 0.0, 1.0);\n\n    return I;\n}\n\nFresnelData mx_init_fresnel_dielectric(float ior, float tf_thickness, float tf_ior)\n{\n    FresnelData fd;\n    fd.model = FRESNEL_MODEL_DIELECTRIC;\n    fd.airy = tf_thickness > 0.0;\n    fd.ior = vec3(ior);\n    fd.extinction = vec3(0.0);\n    fd.F0 = vec3(0.0);\n    fd.F82 = vec3(0.0);\n    fd.F90 = vec3(0.0);\n    fd.exponent = 0.0;\n    fd.tf_thickness = tf_thickness;\n    fd.tf_ior = tf_ior;\n    fd.refraction = false;\n    return fd;\n}\n\nFresnelData mx_init_fresnel_conductor(vec3 ior, vec3 extinction, float tf_thickness, float tf_ior)\n{\n    FresnelData fd;\n    fd.model = FRESNEL_MODEL_CONDUCTOR;\n    fd.airy = tf_thickness > 0.0;\n    fd.ior = ior;\n    fd.extinction = extinction;\n    fd.F0 = vec3(0.0);\n    fd.F82 = vec3(0.0);\n    fd.F90 = vec3(0.0);\n    fd.exponent = 0.0;\n    fd.tf_thickness = tf_thickness;\n    fd.tf_ior = tf_ior;\n    fd.refraction = false;\n    return fd;\n}\n\nFresnelData mx_init_fresnel_schlick(vec3 F0, vec3 F82, vec3 F90, float exponent, float tf_thickness, float tf_ior)\n{\n    FresnelData fd;\n    fd.model = FRESNEL_MODEL_SCHLICK;\n    fd.airy = tf_thickness > 0.0;\n    fd.ior = vec3(0.0);\n    fd.extinction = vec3(0.0);\n    fd.F0 = F0;\n    fd.F82 = F82;\n    fd.F90 = F90;\n    fd.exponent = exponent;\n    fd.tf_thickness = tf_thickness;\n    fd.tf_ior = tf_ior;\n    fd.refraction = false;\n    return fd;\n}\n\nvec3 mx_compute_fresnel(float cosTheta, FresnelData fd)\n{\n    if (fd.airy)\n    {\n         return mx_fresnel_airy(cosTheta, fd);\n    }\n    else if (fd.model == FRESNEL_MODEL_DIELECTRIC)\n    {\n        return vec3(mx_fresnel_dielectric(cosTheta, fd.ior.x));\n    }\n    else if (fd.model == FRESNEL_MODEL_CONDUCTOR)\n    {\n        return mx_fresnel_conductor(cosTheta, fd.ior, fd.extinction);\n    }\n    else\n    {\n        return mx_fresnel_hoffman_schlick(cosTheta, fd);\n    }\n}\n\n// Compute the refraction of a ray through a solid sphere.\nvec3 mx_refraction_solid_sphere(vec3 R, vec3 N, float ior)\n{\n    R = refract(R, N, 1.0 / ior);\n    vec3 N1 = normalize(R * dot(R, N) - N * 0.5);\n    return refract(R, N1, ior);\n}\n\nvec2 mx_latlong_projection(vec3 dir)\n{\n    float latitude = -mx_asin(dir.y) * M_PI_INV + 0.5;\n    float longitude = mx_atan(dir.x, -dir.z) * M_PI_INV * 0.5 + 0.5;\n    return vec2(longitude, latitude);\n}\n\nvec3 mx_latlong_map_lookup(vec3 dir, mat4 transform, float lod, sampler2D envSampler)\n{\n    vec3 envDir = normalize((transform * vec4(dir,0.0)).xyz);\n    vec2 uv = mx_latlong_projection(envDir);\n    return textureLod(envSampler, uv, lod).rgb;\n}\n\n// Return the mip level with the appropriate coverage for a filtered importance sample.\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html\n// Section 20.4 Equation 13\nfloat mx_latlong_compute_lod(vec3 dir, float pdf, float maxMipLevel, int envSamples)\n{\n    const float MIP_LEVEL_OFFSET = 1.5;\n    float effectiveMaxMipLevel = maxMipLevel - MIP_LEVEL_OFFSET;\n    float distortion = sqrt(1.0 - mx_square(dir.y));\n    return max(effectiveMaxMipLevel - 0.5 * log2(float(envSamples) * pdf * distortion), 0.0);\n}\n\nvec3 mx_environment_radiance(vec3 N, vec3 V, vec3 X, vec2 alpha, int distribution, FresnelData fd)\n{\n    // Generate tangent frame.\n    X = normalize(X - dot(X, N) * N);\n    vec3 Y = cross(N, X);\n    mat3 tangentToWorld = mat3(X, Y, N);\n\n    // Transform the view vector to tangent space.\n    V = vec3(dot(V, X), dot(V, Y), dot(V, N));\n\n    // Compute derived properties.\n    float NdotV = clamp(V.z, M_FLOAT_EPS, 1.0);\n    float avgAlpha = mx_average_alpha(alpha);\n    float G1V = mx_ggx_smith_G1(NdotV, avgAlpha);\n    \n    // Integrate outgoing radiance using filtered importance sampling.\n    // http://cgg.mff.cuni.cz/~jaroslav/papers/2008-egsr-fis/2008-egsr-fis-final-embedded.pdf\n    vec3 radiance = vec3(0.0);\n    int envRadianceSamples = u_envRadianceSamples;\n    for (int i = 0; i < envRadianceSamples; i++)\n    {\n        vec2 Xi = mx_spherical_fibonacci(i, envRadianceSamples);\n\n        // Compute the half vector and incoming light direction.\n        vec3 H = mx_ggx_importance_sample_VNDF(Xi, V, alpha);\n        vec3 L = fd.refraction ? mx_refraction_solid_sphere(-V, H, fd.ior.x) : -reflect(V, H);\n        \n        // Compute dot products for this sample.\n        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);\n        float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);\n\n        // Sample the environment light from the given direction.\n        vec3 Lw = tangentToWorld * L;\n        float pdf = mx_ggx_NDF(H, alpha) * G1V / (4.0 * NdotV);\n        float lod = mx_latlong_compute_lod(Lw, pdf, float(u_envRadianceMips - 1), envRadianceSamples);\n        vec3 sampleColor = mx_latlong_map_lookup(Lw, u_envMatrix, lod, u_envRadiance);\n\n        // Compute the Fresnel term.\n        vec3 F = mx_compute_fresnel(VdotH, fd);\n\n        // Compute the geometric term.\n        float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);\n\n        // Compute the combined FG term, which simplifies to inverted Fresnel for refraction.\n        vec3 FG = fd.refraction ? vec3(1.0) - F : F * G;\n\n        // Add the radiance contribution of this sample.\n        // From https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n        //   incidentLight = sampleColor * NdotL\n        //   microfacetSpecular = D * F * G / (4 * NdotL * NdotV)\n        //   pdf = D * G1V / (4 * NdotV);\n        //   radiance = incidentLight * microfacetSpecular / pdf\n        radiance += sampleColor * FG;\n    }\n\n    // Apply the global component of the geometric term and normalize.\n    radiance /= G1V * float(envRadianceSamples);\n\n    // Return the final radiance.\n    return radiance * u_envLightIntensity;\n}\n\nvec3 mx_environment_irradiance(vec3 N)\n{\n    vec3 Li = mx_latlong_map_lookup(N, u_envMatrix, 0.0, u_envIrradiance);\n    return Li * u_envLightIntensity;\n}\n\n\nvec3 mx_surface_transmission(vec3 N, vec3 V, vec3 X, vec2 alpha, int distribution, FresnelData fd, vec3 tint)\n{\n    // Approximate the appearance of surface transmission as glossy\n    // environment map refraction, ignoring any scene geometry that might\n    // be visible through the surface.\n    fd.refraction = true;\n    if (u_refractionTwoSided)\n    {\n        tint = mx_square(tint);\n    }\n    return mx_environment_radiance(N, V, X, alpha, distribution, fd) * tint;\n}\n\nstruct LightData\n{\n    int type;\n    vec3 direction;\n    vec3 color;\n    float intensity;\n};\n\nuniform LightData u_lightData[MAX_LIGHT_SOURCES];\n\nvoid mx_directional_light(LightData light, vec3 position, out lightshader result)\n{\n    result.direction = -light.direction;\n    result.intensity = light.color * light.intensity;\n}\n\nint numActiveLightSources()\n{\n    return min(u_numActiveLightSources, MAX_LIGHT_SOURCES) ;\n}\n\nvoid sampleLightSource(LightData light, vec3 position, out lightshader result)\n{\n    result.intensity = vec3(0.0);\n    result.direction = vec3(0.0);\n    if (light.type == 1)\n    {\n        mx_directional_light(light, position, result);\n    }\n}\n\nvoid mx_roughness_anisotropy(float roughness, float anisotropy, out vec2 result)\n{\n    float roughness_sqr = clamp(roughness*roughness, M_FLOAT_EPS, 1.0);\n    if (anisotropy > 0.0)\n    {\n        float aspect = sqrt(1.0 - clamp(anisotropy, 0.0, 0.98));\n        result.x = min(roughness_sqr / aspect, 1.0);\n        result.y = roughness_sqr * aspect;\n    }\n    else\n    {\n        result.x = roughness_sqr;\n        result.y = roughness_sqr;\n    }\n}\n\n\n// https://fpsunflower.github.io/ckulla/data/s2017_pbs_imageworks_sheen.pdf\n// Equation 2\nfloat mx_imageworks_sheen_NDF(float NdotH, float roughness)\n{\n    float invRoughness = 1.0 / max(roughness, 0.005);\n    float cos2 = NdotH * NdotH;\n    float sin2 = 1.0 - cos2;\n    return (2.0 + invRoughness) * pow(sin2, invRoughness * 0.5) / (2.0 * M_PI);\n}\n\nfloat mx_imageworks_sheen_brdf(float NdotL, float NdotV, float NdotH, float roughness)\n{\n    // Microfacet distribution.\n    float D = mx_imageworks_sheen_NDF(NdotH, roughness);\n\n    // Fresnel and geometry terms are ignored.\n    float F = 1.0;\n    float G = 1.0;\n\n    // We use a smoother denominator, as in:\n    // https://blog.selfshadow.com/publications/s2013-shading-course/rad/s2013_pbs_rad_notes.pdf\n    return D * F * G / (4.0 * (NdotL + NdotV - NdotL*NdotV));\n}\n\n// Rational quadratic fit to Monte Carlo data for Imageworks sheen directional albedo.\nfloat mx_imageworks_sheen_dir_albedo_analytic(float NdotV, float roughness)\n{\n    vec2 r = vec2(13.67300, 1.0) +\n             vec2(-68.78018, 61.57746) * NdotV +\n             vec2(799.08825, 442.78211) * roughness +\n             vec2(-905.00061, 2597.49308) * NdotV * roughness +\n             vec2(60.28956, 121.81241) * mx_square(NdotV) +\n             vec2(1086.96473, 3045.55075) * mx_square(roughness);\n    return r.x / r.y;\n}\n\nfloat mx_imageworks_sheen_dir_albedo_table_lookup(float NdotV, float roughness)\n{\n#if DIRECTIONAL_ALBEDO_METHOD == 1\n    if (textureSize(u_albedoTable, 0).x > 1)\n    {\n        return texture(u_albedoTable, vec2(NdotV, roughness)).b;\n    }\n#endif\n    return 0.0;\n}\n\nfloat mx_imageworks_sheen_dir_albedo_monte_carlo(float NdotV, float roughness)\n{\n    NdotV = clamp(NdotV, M_FLOAT_EPS, 1.0);\n    vec3 V = vec3(sqrt(1.0f - mx_square(NdotV)), 0, NdotV);\n\n    float radiance = 0.0;\n    const int SAMPLE_COUNT = 64;\n    for (int i = 0; i < SAMPLE_COUNT; i++)\n    {\n        vec2 Xi = mx_spherical_fibonacci(i, SAMPLE_COUNT);\n\n        // Compute the incoming light direction and half vector.\n        vec3 L = mx_uniform_sample_hemisphere(Xi);\n        vec3 H = normalize(L + V);\n        \n        // Compute dot products for this sample.\n        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);\n        float NdotH = clamp(H.z, M_FLOAT_EPS, 1.0);\n\n        // Compute sheen reflectance.\n        float reflectance = mx_imageworks_sheen_brdf(NdotL, NdotV, NdotH, roughness);\n\n        // Add the radiance contribution of this sample.\n        //   uniform_pdf = 1 / (2 * PI)\n        //   radiance = reflectance * NdotL / uniform_pdf;\n        radiance += reflectance * NdotL * 2.0 * M_PI;\n    }\n\n    // Return the final directional albedo.\n    return radiance / float(SAMPLE_COUNT);\n}\n\nfloat mx_imageworks_sheen_dir_albedo(float NdotV, float roughness)\n{\n#if DIRECTIONAL_ALBEDO_METHOD == 0\n    float dirAlbedo = mx_imageworks_sheen_dir_albedo_analytic(NdotV, roughness);\n#elif DIRECTIONAL_ALBEDO_METHOD == 1\n    float dirAlbedo = mx_imageworks_sheen_dir_albedo_table_lookup(NdotV, roughness);\n#else\n    float dirAlbedo = mx_imageworks_sheen_dir_albedo_monte_carlo(NdotV, roughness);\n#endif\n    return clamp(dirAlbedo, 0.0, 1.0);\n}\n\n// The following functions are adapted from https://github.com/tizian/ltc-sheen.\n// \"Practical Multiple-Scattering Sheen Using Linearly Transformed Cosines\", Zeltner et al.\n\n// Gaussian fit to directional albedo table.\nfloat mx_zeltner_sheen_dir_albedo(float x, float y)\n{\n    float s = y*(0.0206607 + 1.58491*y)/(0.0379424 + y*(1.32227 + y));\n    float m = y*(-0.193854 + y*(-1.14885 + y*(1.7932 - 0.95943*y*y)))/(0.046391 + y);\n    float o = y*(0.000654023 + (-0.0207818 + 0.119681*y)*y)/(1.26264 + y*(-1.92021 + y));\n    return exp(-0.5*mx_square((x - m)/s))/(s*sqrt(2.0*M_PI)) + o;\n}\n\n// Rational fits to LTC matrix coefficients.\nfloat mx_zeltner_sheen_ltc_aInv(float x, float y)\n{\n    return (2.58126*x + 0.813703*y)*y/(1.0 + 0.310327*x*x + 2.60994*x*y);\n}\n\nfloat mx_zeltner_sheen_ltc_bInv(float x, float y)\n{\n    return sqrt(1.0 - x)*(y - 1.0)*y*y*y/(0.0000254053 + 1.71228*x - 1.71506*x*y + 1.34174*y*y);\n}\n\n// V and N are assumed to be unit vectors.\nmat3 mx_orthonormal_basis_ltc(vec3 V, vec3 N, float NdotV)\n{\n    // Generate a tangent vector in the plane of V and N.\n    // This required to correctly orient the LTC lobe.\n    vec3 X = V - N*NdotV;\n    float lenSqr = dot(X, X);\n    if (lenSqr > 0.0)\n    {\n        X *= mx_inversesqrt(lenSqr);\n        vec3 Y = cross(N, X);\n        return mat3(X, Y, N);\n    }\n\n    // If lenSqr == 0, then V == N, so any orthonormal basis will do.\n    return mx_orthonormal_basis(N);\n}\n\n// Multiplication by directional albedo is handled by the calling function.\nfloat mx_zeltner_sheen_brdf(vec3 L, vec3 V, vec3 N, float NdotV, float roughness)\n{\n    mat3 toLTC = transpose(mx_orthonormal_basis_ltc(V, N, NdotV));\n    vec3 w = toLTC * L;\n\n    float aInv = mx_zeltner_sheen_ltc_aInv(NdotV, roughness);\n    float bInv = mx_zeltner_sheen_ltc_bInv(NdotV, roughness);\n\n    // Transform w to original configuration (clamped cosine).\n    //                 |aInv    0 bInv|\n    // wo = M^-1 . w = |   0 aInv    0| . w\n    //                 |   0    0    1|\n    vec3 wo = vec3(aInv*w.x + bInv*w.z, aInv * w.y, w.z);\n    float lenSqr = dot(wo, wo);\n\n    // D(w) = Do(M^-1.w / ||M^-1.w||) . |M^-1| / ||M^-1.w||^3\n    //      = Do(M^-1.w) . |M^-1| / ||M^-1.w||^4\n    //      = Do(wo) . |M^-1| / dot(wo, wo)^2\n    //      = Do(wo) . aInv^2 / dot(wo, wo)^2\n    //      = Do(wo) . (aInv / dot(wo, wo))^2\n    return max(wo.z, 0.0) * M_PI_INV * mx_square(aInv / lenSqr);\n}\n\nvec3 mx_zeltner_sheen_importance_sample(vec2 Xi, vec3 V, vec3 N, float roughness, out float pdf)\n{\n    float NdotV = clamp(dot(N, V), 0.0, 1.0);\n    roughness = clamp(roughness, 0.01, 1.0); // Clamp to range of original impl.\n\n    vec3 wo = mx_cosine_sample_hemisphere(Xi);\n\n    float aInv = mx_zeltner_sheen_ltc_aInv(NdotV, roughness);\n    float bInv = mx_zeltner_sheen_ltc_bInv(NdotV, roughness);\n\n    // Transform wo from original configuration (clamped cosine).\n    //              |1/aInv      0 -bInv/aInv|\n    // w = M . wo = |     0 1/aInv          0| . wo\n    //              |     0      0          1|    \n    vec3 w = vec3(wo.x/aInv - wo.z*bInv/aInv, wo.y / aInv, wo.z);\n\n    float lenSqr = dot(w, w);\n    w *= mx_inversesqrt(lenSqr);\n\n    // D(w) = Do(wo) . ||M.wo||^3 / |M|\n    //      = Do(wo / ||M.wo||) . ||M.wo||^4 / |M| \n    //      = Do(w) . ||M.wo||^4 / |M| (possible because M doesn't change z component)\n    //      = Do(w) . dot(w, w)^2 * aInv^2\n    //      = Do(w) . (aInv * dot(w, w))^2\n    pdf = max(w.z, 0.0) * M_PI_INV * mx_square(aInv * lenSqr);\n\n    mat3 fromLTC = mx_orthonormal_basis_ltc(V, N, NdotV);\n    w = fromLTC * w;\n\n    return w;\n}\n\nvoid mx_sheen_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, float roughness, vec3 N, int mode, inout BSDF bsdf)\n{\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    N = mx_forward_facing_normal(N, V);\n    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);\n\n    if (mode == 0)\n    {\n        vec3 H = normalize(L + V);\n\n        float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);\n        float NdotH = clamp(dot(N, H), M_FLOAT_EPS, 1.0);\n\n        vec3 fr = color * mx_imageworks_sheen_brdf(NdotL, NdotV, NdotH, roughness);\n        float dirAlbedo = mx_imageworks_sheen_dir_albedo(NdotV, roughness);\n        bsdf.throughput = vec3(1.0 - dirAlbedo * weight);\n\n        // We need to include NdotL from the light integral here\n        // as in this case it's not cancelled out by the BRDF denominator.\n        bsdf.response = fr * NdotL * occlusion * weight;\n    }\n    else\n    {\n        roughness = clamp(roughness, 0.01, 1.0); // Clamp to range of original impl.\n\n        vec3 fr = color * mx_zeltner_sheen_brdf(L, V, N, NdotV, roughness);\n        float dirAlbedo = mx_zeltner_sheen_dir_albedo(NdotV, roughness);\n        bsdf.throughput = vec3(1.0 - dirAlbedo * weight);\n        bsdf.response = dirAlbedo * fr * occlusion * weight;\n    }\n}\n\nvoid mx_sheen_bsdf_indirect(vec3 V, float weight, vec3 color, float roughness, vec3 N, int mode, inout BSDF bsdf)\n{\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    N = mx_forward_facing_normal(N, V);\n    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);\n\n    float dirAlbedo;\n    if (mode == 0)\n    {\n        dirAlbedo = mx_imageworks_sheen_dir_albedo(NdotV, roughness);\n    }\n    else\n    {\n        roughness = clamp(roughness, 0.01, 1.0); // Clamp to range of original impl.\n        dirAlbedo = mx_zeltner_sheen_dir_albedo(NdotV, roughness);\n    }\n\n    vec3 Li = mx_environment_irradiance(N);\n    bsdf.throughput = vec3(1.0 - dirAlbedo * weight);\n    bsdf.response = Li * color * dirAlbedo * weight;\n}\n\nvoid mx_luminance_color3(vec3 _in, vec3 lumacoeffs, out vec3 result)\n{\n    result = vec3(dot(_in, lumacoeffs));\n}\n\nmat4 mx_rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = mx_sin(angle);\n    float c = mx_cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mx_rotate_vector3(vec3 _in, float amount, vec3 axis, out vec3 result)\n{\n    float rotationRadians = mx_radians(amount);\n    mat4 m = mx_rotationMatrix(axis, rotationRadians);\n    result = (m * vec4(_in, 1.0)).xyz;\n}\n\nvoid mx_artistic_ior(vec3 reflectivity, vec3 edge_color, out vec3 ior, out vec3 extinction)\n{\n    // \"Artist Friendly Metallic Fresnel\", Ole Gulbrandsen, 2014\n    // http://jcgt.org/published/0003/04/03/paper.pdf\n\n    vec3 r = clamp(reflectivity, 0.0, 0.99);\n    vec3 r_sqrt = sqrt(r);\n    vec3 n_min = (1.0 - r) / (1.0 + r);\n    vec3 n_max = (1.0 + r_sqrt) / (1.0 - r_sqrt);\n    ior = mix(n_max, n_min, edge_color);\n\n    vec3 np1 = ior + 1.0;\n    vec3 nm1 = ior - 1.0;\n    vec3 k2 = (np1*np1 * r - nm1*nm1) / (1.0 - r);\n    k2 = max(k2, 0.0);\n    extinction = sqrt(k2);\n}\n\nvoid mx_uniform_edf(vec3 N, vec3 L, vec3 color, out EDF result)\n{\n    result = color;\n}\n\n\nvoid mx_dielectric_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 tint, float ior, vec2 roughness, float thinfilm_thickness, float thinfilm_ior, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)\n{\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    N = mx_forward_facing_normal(N, V);\n\n    X = normalize(X - dot(X, N) * N);\n    vec3 Y = cross(N, X);\n    vec3 H = normalize(L + V);\n\n    float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);\n    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);\n    float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);\n\n    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);\n    float avgAlpha = mx_average_alpha(safeAlpha);\n    vec3 Ht = vec3(dot(H, X), dot(H, Y), dot(H, N));\n\n    vec3 safeTint = max(tint, 0.0);\n    FresnelData fd = mx_init_fresnel_dielectric(ior, thinfilm_thickness, thinfilm_ior);\n    vec3  F = mx_compute_fresnel(VdotH, fd);\n    float D = mx_ggx_NDF(Ht, safeAlpha);\n    float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);\n\n    float F0 = mx_ior_to_f0(ior);\n    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);\n    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, F0, 1.0) * comp;\n    bsdf.throughput = 1.0 - dirAlbedo * weight;\n\n    // Note: NdotL is cancelled out\n    bsdf.response = D * F * G * comp * safeTint * occlusion * weight / (4.0 * NdotV);\n}\n\nvoid mx_dielectric_bsdf_transmission(vec3 V, float weight, vec3 tint, float ior, vec2 roughness, float thinfilm_thickness, float thinfilm_ior, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)\n{\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    N = mx_forward_facing_normal(N, V);\n    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);\n\n    vec3 safeTint = max(tint, 0.0);\n    FresnelData fd = mx_init_fresnel_dielectric(ior, thinfilm_thickness, thinfilm_ior);\n    vec3 F = mx_compute_fresnel(NdotV, fd);\n\n    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);\n    float avgAlpha = mx_average_alpha(safeAlpha);\n\n    float F0 = mx_ior_to_f0(ior);\n    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);\n    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, F0, 1.0) * comp;\n    bsdf.throughput = 1.0 - dirAlbedo * weight;\n\n    if (scatter_mode != 0)\n    {\n        bsdf.response = mx_surface_transmission(N, V, X, safeAlpha, distribution, fd, safeTint) * weight;\n    }\n}\n\nvoid mx_dielectric_bsdf_indirect(vec3 V, float weight, vec3 tint, float ior, vec2 roughness, float thinfilm_thickness, float thinfilm_ior, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)\n{\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    N = mx_forward_facing_normal(N, V);\n\n    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);\n\n    vec3 safeTint = max(tint, 0.0);\n    FresnelData fd = mx_init_fresnel_dielectric(ior, thinfilm_thickness, thinfilm_ior);\n    vec3 F = mx_compute_fresnel(NdotV, fd);\n\n    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);\n    float avgAlpha = mx_average_alpha(safeAlpha);\n\n    float F0 = mx_ior_to_f0(ior);\n    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);\n    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, F0, 1.0) * comp;\n    bsdf.throughput = 1.0 - dirAlbedo * weight;\n\n    vec3 Li = mx_environment_radiance(N, V, X, safeAlpha, distribution, fd);\n    bsdf.response = Li * safeTint * comp * weight;\n}\n\n\nvoid mx_conductor_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 ior_n, vec3 ior_k, vec2 roughness, float thinfilm_thickness, float thinfilm_ior, vec3 N, vec3 X, int distribution, inout BSDF bsdf)\n{\n    bsdf.throughput = vec3(0.0);\n\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    N = mx_forward_facing_normal(N, V);\n\n    X = normalize(X - dot(X, N) * N);\n    vec3 Y = cross(N, X);\n    vec3 H = normalize(L + V);\n\n    float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);\n    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);\n    float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);\n\n    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);\n    float avgAlpha = mx_average_alpha(safeAlpha);\n    vec3 Ht = vec3(dot(H, X), dot(H, Y), dot(H, N));\n\n    FresnelData fd = mx_init_fresnel_conductor(ior_n, ior_k, thinfilm_thickness, thinfilm_ior);\n    vec3 F = mx_compute_fresnel(VdotH, fd);\n    float D = mx_ggx_NDF(Ht, safeAlpha);\n    float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);\n\n    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);\n\n    // Note: NdotL is cancelled out\n    bsdf.response = D * F * G * comp * occlusion * weight / (4.0 * NdotV);\n}\n\nvoid mx_conductor_bsdf_indirect(vec3 V, float weight, vec3 ior_n, vec3 ior_k, vec2 roughness, float thinfilm_thickness, float thinfilm_ior, vec3 N, vec3 X, int distribution, inout BSDF bsdf)\n{\n    bsdf.throughput = vec3(0.0);\n\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    N = mx_forward_facing_normal(N, V);\n\n    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);\n\n    FresnelData fd = mx_init_fresnel_conductor(ior_n, ior_k, thinfilm_thickness, thinfilm_ior);\n    vec3 F = mx_compute_fresnel(NdotV, fd);\n\n    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);\n    float avgAlpha = mx_average_alpha(safeAlpha);\n    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);\n\n    vec3 Li = mx_environment_radiance(N, V, X, safeAlpha, distribution, fd);\n\n    bsdf.response = Li * comp * weight;\n}\n\n// We fake diffuse transmission by using diffuse reflection from the opposite side.\n// So this BTDF is really a BRDF.\nvoid mx_translucent_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, vec3 normal, inout BSDF bsdf)\n{\n    bsdf.throughput = vec3(0.0);\n\n    // Invert normal since we're transmitting light from the other side\n    float NdotL = dot(L, -normal);\n    if (NdotL <= 0.0 || weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    bsdf.response = color * weight * NdotL * M_PI_INV;\n}\n\nvoid mx_translucent_bsdf_indirect(vec3 V, float weight, vec3 color, vec3 normal, inout BSDF bsdf)\n{\n    bsdf.throughput = vec3(0.0);\n\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    // Invert normal since we're transmitting light from the other side\n    vec3 Li = mx_environment_irradiance(-normal);\n    bsdf.response = Li * color * weight;\n}\n\n\nconst float FUJII_CONSTANT_1 = 0.5 - 2.0 / (3.0 * M_PI);\nconst float FUJII_CONSTANT_2 = 2.0 / 3.0 - 28.0 / (15.0 * M_PI);\n\n// Qualitative Oren-Nayar diffuse with simplified math:\n// https://www1.cs.columbia.edu/CAVE/publications/pdfs/Oren_SIGGRAPH94.pdf\nfloat mx_oren_nayar_diffuse(float NdotV, float NdotL, float LdotV, float roughness)\n{\n    float s = LdotV - NdotL * NdotV;\n    float stinv = (s > 0.0) ? s / max(NdotL, NdotV) : 0.0;\n\n    float sigma2 = mx_square(roughness);\n    float A = 1.0 - 0.5 * (sigma2 / (sigma2 + 0.33));\n    float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n    return A + B * stinv;\n}\n\n// Rational quadratic fit to Monte Carlo data for Oren-Nayar directional albedo.\nfloat mx_oren_nayar_diffuse_dir_albedo_analytic(float NdotV, float roughness)\n{\n    vec2 r = vec2(1.0, 1.0) +\n             vec2(-0.4297, -0.6076) * roughness +\n             vec2(-0.7632, -0.4993) * NdotV * roughness +\n             vec2(1.4385, 2.0315) * mx_square(roughness);\n    return r.x / r.y;\n}\n\nfloat mx_oren_nayar_diffuse_dir_albedo_table_lookup(float NdotV, float roughness)\n{\n#if DIRECTIONAL_ALBEDO_METHOD == 1\n    if (textureSize(u_albedoTable, 0).x > 1)\n    {\n        return texture(u_albedoTable, vec2(NdotV, roughness)).b;\n    }\n#endif\n    return 0.0;\n}\n\nfloat mx_oren_nayar_diffuse_dir_albedo_monte_carlo(float NdotV, float roughness)\n{\n    NdotV = clamp(NdotV, M_FLOAT_EPS, 1.0);\n    vec3 V = vec3(sqrt(1.0 - mx_square(NdotV)), 0, NdotV);\n\n    float radiance = 0.0;\n    const int SAMPLE_COUNT = 64;\n    for (int i = 0; i < SAMPLE_COUNT; i++)\n    {\n        vec2 Xi = mx_spherical_fibonacci(i, SAMPLE_COUNT);\n\n        // Compute the incoming light direction.\n        vec3 L = mx_uniform_sample_hemisphere(Xi);\n        \n        // Compute dot products for this sample.\n        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);\n        float LdotV = clamp(dot(L, V), M_FLOAT_EPS, 1.0);\n\n        // Compute diffuse reflectance.\n        float reflectance = mx_oren_nayar_diffuse(NdotV, NdotL, LdotV, roughness);\n\n        // Add the radiance contribution of this sample.\n        //   uniform_pdf = 1 / (2 * PI)\n        //   radiance = (reflectance * NdotL) / (uniform_pdf * PI);\n        radiance += reflectance * NdotL;\n    }\n\n    // Apply global components and normalize.\n    radiance *= 2.0 / float(SAMPLE_COUNT);\n\n    // Return the final directional albedo.\n    return radiance;\n}\n\nfloat mx_oren_nayar_diffuse_dir_albedo(float NdotV, float roughness)\n{\n#if DIRECTIONAL_ALBEDO_METHOD == 2\n    float dirAlbedo = mx_oren_nayar_diffuse_dir_albedo_monte_carlo(NdotV, roughness);\n#else\n    float dirAlbedo = mx_oren_nayar_diffuse_dir_albedo_analytic(NdotV, roughness);\n#endif\n    return clamp(dirAlbedo, 0.0, 1.0);\n}\n\n// Improved Oren-Nayar diffuse from Fujii:\n// https://mimosa-pudica.net/improved-oren-nayar.html\nfloat mx_oren_nayar_fujii_diffuse_dir_albedo(float cosTheta, float roughness)\n{\n    float A = 1.0 / (1.0 + FUJII_CONSTANT_1 * roughness);\n    float B = roughness * A;\n    float Si = sqrt(max(0.0, 1.0 - mx_square(cosTheta)));\n    float G = Si * (mx_acos(clamp(cosTheta, -1.0, 1.0)) - Si * cosTheta) +\n              2.0 * ((Si / cosTheta) * (1.0 - Si * Si * Si) - Si) / 3.0;\n    return A + (B * G * M_PI_INV);\n}\n\nfloat mx_oren_nayar_fujii_diffuse_avg_albedo(float roughness)\n{\n    float A = 1.0 / (1.0 + FUJII_CONSTANT_1 * roughness);\n    return A * (1.0 + FUJII_CONSTANT_2 * roughness);\n}   \n\n// Energy-compensated Oren-Nayar diffuse from OpenPBR Surface:\n// https://academysoftwarefoundation.github.io/OpenPBR/\nvec3 mx_oren_nayar_compensated_diffuse(float NdotV, float NdotL, float LdotV, float roughness, vec3 color)\n{\n    float s = LdotV - NdotL * NdotV;\n    float stinv = (s > 0.0) ? s / max(NdotL, NdotV) : s;\n\n    // Compute the single-scatter lobe.\n    float A = 1.0 / (1.0 + FUJII_CONSTANT_1 * roughness);\n    vec3 lobeSingleScatter = color * A * (1.0 + roughness * stinv);\n\n    // Compute the multi-scatter lobe.\n    float dirAlbedoV = mx_oren_nayar_fujii_diffuse_dir_albedo(NdotV, roughness);\n    float dirAlbedoL = mx_oren_nayar_fujii_diffuse_dir_albedo(NdotL, roughness);\n    float avgAlbedo = mx_oren_nayar_fujii_diffuse_avg_albedo(roughness);\n    vec3 colorMultiScatter = mx_square(color) * avgAlbedo /\n                             (vec3(1.0) - color * max(0.0, 1.0 - avgAlbedo));\n    vec3 lobeMultiScatter = colorMultiScatter *\n                            max(M_FLOAT_EPS, 1.0 - dirAlbedoV) *\n                            max(M_FLOAT_EPS, 1.0 - dirAlbedoL) /\n                            max(M_FLOAT_EPS, 1.0 - avgAlbedo);\n\n    // Return the sum.\n    return lobeSingleScatter + lobeMultiScatter;\n}\n\nvec3 mx_oren_nayar_compensated_diffuse_dir_albedo(float cosTheta, float roughness, vec3 color)\n{\n    float dirAlbedo = mx_oren_nayar_fujii_diffuse_dir_albedo(cosTheta, roughness);\n    float avgAlbedo = mx_oren_nayar_fujii_diffuse_avg_albedo(roughness);\n    vec3 colorMultiScatter = mx_square(color) * avgAlbedo /\n                             (vec3(1.0) - color * max(0.0, 1.0 - avgAlbedo));\n    return mix(colorMultiScatter, color, dirAlbedo);\n}\n  \n// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf\n// Section 5.3\nfloat mx_burley_diffuse(float NdotV, float NdotL, float LdotH, float roughness)\n{\n    float F90 = 0.5 + (2.0 * roughness * mx_square(LdotH));\n    float refL = mx_fresnel_schlick(NdotL, 1.0, F90);\n    float refV = mx_fresnel_schlick(NdotV, 1.0, F90);\n    return refL * refV;\n}\n\n// Compute the directional albedo component of Burley diffuse for the given\n// view angle and roughness.  Curve fit provided by Stephen Hill.\nfloat mx_burley_diffuse_dir_albedo(float NdotV, float roughness)\n{\n    float x = NdotV;\n    float fit0 = 0.97619 - 0.488095 * mx_pow5(1.0 - x);\n    float fit1 = 1.55754 + (-2.02221 + (2.56283 - 1.06244 * x) * x) * x;\n    return mix(fit0, fit1, roughness);\n}\n\n// Evaluate the Burley diffusion profile for the given distance and diffusion shape.\n// Based on https://graphics.pixar.com/library/ApproxBSSRDF/\nvec3 mx_burley_diffusion_profile(float dist, vec3 shape)\n{\n    vec3 num1 = exp(-shape * dist);\n    vec3 num2 = exp(-shape * dist / 3.0);\n    float denom = max(dist, M_FLOAT_EPS);\n    return (num1 + num2) / denom;\n}\n\n// Integrate the Burley diffusion profile over a sphere of the given radius.\n// Inspired by Eric Penner's presentation in http://advances.realtimerendering.com/s2011/\nvec3 mx_integrate_burley_diffusion(vec3 N, vec3 L, float radius, vec3 mfp)\n{\n    float theta = mx_acos(dot(N, L));\n\n    // Estimate the Burley diffusion shape from mean free path.\n    vec3 shape = vec3(1.0) / max(mfp, 0.1);\n\n    // Integrate the profile over the sphere.\n    vec3 sumD = vec3(0.0);\n    vec3 sumR = vec3(0.0);\n    const int SAMPLE_COUNT = 32;\n    const float SAMPLE_WIDTH = (2.0 * M_PI) / float(SAMPLE_COUNT);\n    for (int i = 0; i < SAMPLE_COUNT; i++)\n    {\n        float x = -M_PI + (float(i) + 0.5) * SAMPLE_WIDTH;\n        float dist = radius * abs(2.0 * mx_sin(x * 0.5));\n        vec3 R = mx_burley_diffusion_profile(dist, shape);\n        sumD += R * max(mx_cos(theta + x), 0.0);\n        sumR += R;\n    }\n\n    return sumD / sumR;\n}\n\nvec3 mx_subsurface_scattering_approx(vec3 N, vec3 L, vec3 P, vec3 albedo, vec3 mfp)\n{\n    float curvature = length(fwidth(N)) / length(fwidth(P));\n    float radius = 1.0 / max(curvature, 0.01);\n    return albedo * mx_integrate_burley_diffusion(N, L, radius, mfp) / vec3(M_PI);\n}\n\nvoid mx_subsurface_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, vec3 radius, float anisotropy, vec3 normal, inout BSDF bsdf)\n{\n    bsdf.throughput = vec3(0.0);\n\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    normal = mx_forward_facing_normal(normal, V);\n\n    vec3 sss = mx_subsurface_scattering_approx(normal, L, P, color, radius);\n    float NdotL = clamp(dot(normal, L), M_FLOAT_EPS, 1.0);\n    float visibleOcclusion = 1.0 - NdotL * (1.0 - occlusion);\n    bsdf.response = sss * visibleOcclusion * weight;\n}\n\nvoid mx_subsurface_bsdf_indirect(vec3 V, float weight, vec3 color, vec3 radius, float anisotropy, vec3 normal, inout BSDF bsdf)\n{\n    bsdf.throughput = vec3(0.0);\n\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    normal = mx_forward_facing_normal(normal, V);\n\n    // For now, we render indirect subsurface as simple indirect diffuse.\n    vec3 Li = mx_environment_irradiance(normal);\n    bsdf.response = Li * color * weight;\n}\n\n\nvoid mx_oren_nayar_diffuse_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, float roughness, vec3 normal, bool energy_compensation, inout BSDF bsdf)\n{\n    bsdf.throughput = vec3(0.0);\n\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    normal = mx_forward_facing_normal(normal, V);\n\n    float NdotV = clamp(dot(normal, V), M_FLOAT_EPS, 1.0);\n    float NdotL = clamp(dot(normal, L), M_FLOAT_EPS, 1.0);\n    float LdotV = clamp(dot(L, V), M_FLOAT_EPS, 1.0);\n\n    vec3 diffuse = energy_compensation ?\n                   mx_oren_nayar_compensated_diffuse(NdotV, NdotL, LdotV, roughness, color) :\n                   mx_oren_nayar_diffuse(NdotV, NdotL, LdotV, roughness) * color;\n    bsdf.response = diffuse * occlusion * weight * NdotL * M_PI_INV;\n}\n\nvoid mx_oren_nayar_diffuse_bsdf_indirect(vec3 V, float weight, vec3 color, float roughness, vec3 normal, bool energy_compensation, inout BSDF bsdf)\n{\n    bsdf.throughput = vec3(0.0);\n\n    if (weight < M_FLOAT_EPS)\n    {\n        return;\n    }\n\n    normal = mx_forward_facing_normal(normal, V);\n\n    float NdotV = clamp(dot(normal, V), M_FLOAT_EPS, 1.0);\n\n    vec3 diffuse = energy_compensation ?\n                   mx_oren_nayar_compensated_diffuse_dir_albedo(NdotV, roughness, color) :\n                   mx_oren_nayar_diffuse_dir_albedo(NdotV, roughness) * color;\n    vec3 Li = mx_environment_irradiance(normal);\n    bsdf.response = Li * diffuse * weight;\n}\n\nvoid NG_convert_float_color3(float in1, out vec3 out1)\n{\n    vec3 combine_out = vec3(in1,in1,in1);\n    out1 = combine_out;\n}\n\n\nvoid mx_generalized_schlick_edf(vec3 N, vec3 V, vec3 color0, vec3 color90, float exponent, EDF base, out EDF result)\n{\n    N = mx_forward_facing_normal(N, V);\n    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);\n    vec3 f = mx_fresnel_schlick(NdotV, color0, color90, exponent);\n    result = base * f;\n}\n\nvoid NG_standard_surface_surfaceshader_100(float base, vec3 base_color, float diffuse_roughness, float metalness, float specular, vec3 specular_color, float specular_roughness, float specular_IOR, float specular_anisotropy, float specular_rotation, float transmission, vec3 transmission_color, float transmission_depth, vec3 transmission_scatter, float transmission_scatter_anisotropy, float transmission_dispersion, float transmission_extra_roughness, float subsurface, vec3 subsurface_color, vec3 subsurface_radius, float subsurface_scale, float subsurface_anisotropy, float sheen, vec3 sheen_color, float sheen_roughness, float coat, vec3 coat_color, float coat_roughness, float coat_anisotropy, float coat_rotation, float coat_IOR, vec3 coat_normal, float coat_affect_color, float coat_affect_roughness, float thin_film_thickness, float thin_film_IOR, float emission, vec3 emission_color, vec3 opacity, bool thin_walled, vec3 normal, vec3 tangent, out surfaceshader out1)\n{\n    vec2 coat_roughness_vector_out = vec2(0.0);\n    mx_roughness_anisotropy(coat_roughness, coat_anisotropy, coat_roughness_vector_out);\n    const float coat_tangent_rotate_degree_in2_tmp = 360.000000;\n    float coat_tangent_rotate_degree_out = coat_rotation * coat_tangent_rotate_degree_in2_tmp;\n    vec3 metal_reflectivity_out = base_color * base;\n    vec3 metal_edgecolor_out = specular_color * specular;\n    float coat_affect_roughness_multiply1_out = coat_affect_roughness * coat;\n    const float tangent_rotate_degree_in2_tmp = 360.000000;\n    float tangent_rotate_degree_out = specular_rotation * tangent_rotate_degree_in2_tmp;\n    float transmission_roughness_add_out = specular_roughness + transmission_extra_roughness;\n    const float subsurface_color_nonnegative_in2_tmp = 0.000000;\n    vec3 subsurface_color_nonnegative_out = max(subsurface_color, subsurface_color_nonnegative_in2_tmp);\n    const float coat_clamped_low_tmp = 0.000000;\n    const float coat_clamped_high_tmp = 1.000000;\n    float coat_clamped_out = clamp(coat, coat_clamped_low_tmp, coat_clamped_high_tmp);\n    vec3 subsurface_radius_scaled_out = subsurface_radius * subsurface_scale;\n    float subsurface_selector_out = float(thin_walled);\n    const float base_color_nonnegative_in2_tmp = 0.000000;\n    vec3 base_color_nonnegative_out = max(base_color, base_color_nonnegative_in2_tmp);\n    const vec3 coat_attenuation_bg_tmp = vec3(1.000000, 1.000000, 1.000000);\n    vec3 coat_attenuation_out = mix(coat_attenuation_bg_tmp, coat_color, coat);\n    const float one_minus_coat_ior_in1_tmp = 1.000000;\n    float one_minus_coat_ior_out = one_minus_coat_ior_in1_tmp - coat_IOR;\n    const float one_plus_coat_ior_in1_tmp = 1.000000;\n    float one_plus_coat_ior_out = one_plus_coat_ior_in1_tmp + coat_IOR;\n    vec3 emission_weight_out = emission_color * emission;\n    vec3 opacity_luminance_out = vec3(0.0);\n    mx_luminance_color3(opacity, vec3(0.272229, 0.674082, 0.053689), opacity_luminance_out);\n    vec3 coat_tangent_rotate_out = vec3(0.0);\n    mx_rotate_vector3(tangent, coat_tangent_rotate_degree_out, coat_normal, coat_tangent_rotate_out);\n    vec3 artistic_ior_ior = vec3(0.0);\n    vec3 artistic_ior_extinction = vec3(0.0);\n    mx_artistic_ior(metal_reflectivity_out, metal_edgecolor_out, artistic_ior_ior, artistic_ior_extinction);\n    float coat_affect_roughness_multiply2_out = coat_affect_roughness_multiply1_out * coat_roughness;\n    vec3 tangent_rotate_out = vec3(0.0);\n    mx_rotate_vector3(tangent, tangent_rotate_degree_out, normal, tangent_rotate_out);\n    const float transmission_roughness_clamped_low_tmp = 0.000000;\n    const float transmission_roughness_clamped_high_tmp = 1.000000;\n    float transmission_roughness_clamped_out = clamp(transmission_roughness_add_out, transmission_roughness_clamped_low_tmp, transmission_roughness_clamped_high_tmp);\n    float coat_gamma_multiply_out = coat_clamped_out * coat_affect_color;\n    float coat_ior_to_F0_sqrt_out = one_minus_coat_ior_out / one_plus_coat_ior_out;\n    const int opacity_luminance_float_index_tmp = 0;\n    float opacity_luminance_float_out = opacity_luminance_out[opacity_luminance_float_index_tmp];\n    vec3 coat_tangent_rotate_normalize_out = normalize(coat_tangent_rotate_out);\n    const float coat_affected_roughness_fg_tmp = 1.000000;\n    float coat_affected_roughness_out = mix(specular_roughness, coat_affected_roughness_fg_tmp, coat_affect_roughness_multiply2_out);\n    vec3 tangent_rotate_normalize_out = normalize(tangent_rotate_out);\n    const float coat_affected_transmission_roughness_fg_tmp = 1.000000;\n    float coat_affected_transmission_roughness_out = mix(transmission_roughness_clamped_out, coat_affected_transmission_roughness_fg_tmp, coat_affect_roughness_multiply2_out);\n    const float coat_gamma_in2_tmp = 1.000000;\n    float coat_gamma_out = coat_gamma_multiply_out + coat_gamma_in2_tmp;\n    float coat_ior_to_F0_out = coat_ior_to_F0_sqrt_out * coat_ior_to_F0_sqrt_out;\n    const float coat_tangent_value2_tmp = 0.000000;\n    vec3 coat_tangent_out = (coat_anisotropy > coat_tangent_value2_tmp) ? coat_tangent_rotate_normalize_out : tangent;\n    vec2 main_roughness_out = vec2(0.0);\n    mx_roughness_anisotropy(coat_affected_roughness_out, specular_anisotropy, main_roughness_out);\n    const float main_tangent_value2_tmp = 0.000000;\n    vec3 main_tangent_out = (specular_anisotropy > main_tangent_value2_tmp) ? tangent_rotate_normalize_out : tangent;\n    vec2 transmission_roughness_out = vec2(0.0);\n    mx_roughness_anisotropy(coat_affected_transmission_roughness_out, specular_anisotropy, transmission_roughness_out);\n    vec3 coat_affected_subsurface_color_out = pow(subsurface_color_nonnegative_out, vec3(coat_gamma_out));\n    vec3 coat_affected_diffuse_color_out = pow(base_color_nonnegative_out, vec3(coat_gamma_out));\n    const float one_minus_coat_ior_to_F0_in1_tmp = 1.000000;\n    float one_minus_coat_ior_to_F0_out = one_minus_coat_ior_to_F0_in1_tmp - coat_ior_to_F0_out;\n    vec3 emission_color0_out = vec3(0.0);\n    NG_convert_float_color3(one_minus_coat_ior_to_F0_out, emission_color0_out);\n    surfaceshader shader_constructor_out = surfaceshader(vec3(0.0),vec3(0.0));\n    {\n        vec3 N = normalize(normalWorld);\n        vec3 V = normalize(u_viewPosition - positionWorld);\n        vec3 P = positionWorld;\n\n        float surfaceOpacity = opacity_luminance_float_out;\n\n        // Shadow occlusion\n        float occlusion = 1.0;\n\n        // Light loop\n        int numLights = numActiveLightSources();\n        lightshader lightShader;\n        for (int activeLightIndex = 0; activeLightIndex < numLights; ++activeLightIndex)\n        {\n            sampleLightSource(u_lightData[activeLightIndex], positionWorld, lightShader);\n            vec3 L = lightShader.direction;\n\n            // Calculate the BSDF response for this light source\n            BSDF coat_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_dielectric_bsdf_reflection(L, V, P, occlusion, coat, vec3(1.000000, 1.000000, 1.000000), coat_IOR, coat_roughness_vector_out, 0.000000, 1.500000, coat_normal, coat_tangent_out, 0, 0, coat_bsdf_out);\n            BSDF metal_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_conductor_bsdf_reflection(L, V, P, occlusion, 1.000000, artistic_ior_ior, artistic_ior_extinction, main_roughness_out, thin_film_thickness, thin_film_IOR, normal, main_tangent_out, 0, metal_bsdf_out);\n            BSDF specular_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_dielectric_bsdf_reflection(L, V, P, occlusion, specular, specular_color, specular_IOR, main_roughness_out, thin_film_thickness, thin_film_IOR, normal, main_tangent_out, 0, 0, specular_bsdf_out);\n            BSDF transmission_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            BSDF sheen_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_sheen_bsdf_reflection(L, V, P, occlusion, sheen, sheen_color, sheen_roughness, normal, 0, sheen_bsdf_out);\n            BSDF translucent_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_translucent_bsdf_reflection(L, V, P, occlusion, 1.000000, coat_affected_subsurface_color_out, normal, translucent_bsdf_out);\n            BSDF subsurface_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_subsurface_bsdf_reflection(L, V, P, occlusion, 1.000000, coat_affected_subsurface_color_out, subsurface_radius_scaled_out, subsurface_anisotropy, normal, subsurface_bsdf_out);\n            BSDF selected_subsurface_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            selected_subsurface_bsdf_out.response = mix(subsurface_bsdf_out.response, translucent_bsdf_out.response, subsurface_selector_out);\n            selected_subsurface_bsdf_out.throughput = mix(subsurface_bsdf_out.throughput, translucent_bsdf_out.throughput, subsurface_selector_out);\n            BSDF diffuse_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_oren_nayar_diffuse_bsdf_reflection(L, V, P, occlusion, base, coat_affected_diffuse_color_out, diffuse_roughness, normal, false, diffuse_bsdf_out);\n            BSDF subsurface_mix_out = BSDF(vec3(0.0),vec3(1.0));\n            subsurface_mix_out.response = mix(diffuse_bsdf_out.response, selected_subsurface_bsdf_out.response, subsurface);\n            subsurface_mix_out.throughput = mix(diffuse_bsdf_out.throughput, selected_subsurface_bsdf_out.throughput, subsurface);\n            BSDF sheen_layer_out = BSDF(vec3(0.0),vec3(1.0));\n            sheen_layer_out.response = sheen_bsdf_out.response + subsurface_mix_out.response * sheen_bsdf_out.throughput;\n            sheen_layer_out.throughput = sheen_bsdf_out.throughput * subsurface_mix_out.throughput;\n            BSDF transmission_mix_out = BSDF(vec3(0.0),vec3(1.0));\n            transmission_mix_out.response = mix(sheen_layer_out.response, transmission_bsdf_out.response, transmission);\n            transmission_mix_out.throughput = mix(sheen_layer_out.throughput, transmission_bsdf_out.throughput, transmission);\n            BSDF specular_layer_out = BSDF(vec3(0.0),vec3(1.0));\n            specular_layer_out.response = specular_bsdf_out.response + transmission_mix_out.response * specular_bsdf_out.throughput;\n            specular_layer_out.throughput = specular_bsdf_out.throughput * transmission_mix_out.throughput;\n            BSDF metalness_mix_out = BSDF(vec3(0.0),vec3(1.0));\n            metalness_mix_out.response = mix(specular_layer_out.response, metal_bsdf_out.response, metalness);\n            metalness_mix_out.throughput = mix(specular_layer_out.throughput, metal_bsdf_out.throughput, metalness);\n            vec3 thin_film_layer_attenuated_out_in2_clamped = clamp(coat_attenuation_out, 0.0, 1.0);\n            BSDF thin_film_layer_attenuated_out = BSDF(vec3(0.0),vec3(1.0));\n            thin_film_layer_attenuated_out.response = metalness_mix_out.response * thin_film_layer_attenuated_out_in2_clamped;\n            thin_film_layer_attenuated_out.throughput = metalness_mix_out.throughput * thin_film_layer_attenuated_out_in2_clamped;\n            BSDF coat_layer_out = BSDF(vec3(0.0),vec3(1.0));\n            coat_layer_out.response = coat_bsdf_out.response + thin_film_layer_attenuated_out.response * coat_bsdf_out.throughput;\n            coat_layer_out.throughput = coat_bsdf_out.throughput * thin_film_layer_attenuated_out.throughput;\n\n            // Accumulate the light's contribution\n            shader_constructor_out.color += lightShader.intensity * coat_layer_out.response;\n        }\n\n        // Ambient occlusion\n        occlusion = 1.0;\n\n        // Add environment contribution\n        {\n            BSDF coat_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_dielectric_bsdf_indirect(V, coat, vec3(1.000000, 1.000000, 1.000000), coat_IOR, coat_roughness_vector_out, 0.000000, 1.500000, coat_normal, coat_tangent_out, 0, 0, coat_bsdf_out);\n            BSDF metal_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_conductor_bsdf_indirect(V, 1.000000, artistic_ior_ior, artistic_ior_extinction, main_roughness_out, thin_film_thickness, thin_film_IOR, normal, main_tangent_out, 0, metal_bsdf_out);\n            BSDF specular_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_dielectric_bsdf_indirect(V, specular, specular_color, specular_IOR, main_roughness_out, thin_film_thickness, thin_film_IOR, normal, main_tangent_out, 0, 0, specular_bsdf_out);\n            BSDF transmission_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            BSDF sheen_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_sheen_bsdf_indirect(V, sheen, sheen_color, sheen_roughness, normal, 0, sheen_bsdf_out);\n            BSDF translucent_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_translucent_bsdf_indirect(V, 1.000000, coat_affected_subsurface_color_out, normal, translucent_bsdf_out);\n            BSDF subsurface_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_subsurface_bsdf_indirect(V, 1.000000, coat_affected_subsurface_color_out, subsurface_radius_scaled_out, subsurface_anisotropy, normal, subsurface_bsdf_out);\n            BSDF selected_subsurface_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            selected_subsurface_bsdf_out.response = mix(subsurface_bsdf_out.response, translucent_bsdf_out.response, subsurface_selector_out);\n            selected_subsurface_bsdf_out.throughput = mix(subsurface_bsdf_out.throughput, translucent_bsdf_out.throughput, subsurface_selector_out);\n            BSDF diffuse_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_oren_nayar_diffuse_bsdf_indirect(V, base, coat_affected_diffuse_color_out, diffuse_roughness, normal, false, diffuse_bsdf_out);\n            BSDF subsurface_mix_out = BSDF(vec3(0.0),vec3(1.0));\n            subsurface_mix_out.response = mix(diffuse_bsdf_out.response, selected_subsurface_bsdf_out.response, subsurface);\n            subsurface_mix_out.throughput = mix(diffuse_bsdf_out.throughput, selected_subsurface_bsdf_out.throughput, subsurface);\n            BSDF sheen_layer_out = BSDF(vec3(0.0),vec3(1.0));\n            sheen_layer_out.response = sheen_bsdf_out.response + subsurface_mix_out.response * sheen_bsdf_out.throughput;\n            sheen_layer_out.throughput = sheen_bsdf_out.throughput * subsurface_mix_out.throughput;\n            BSDF transmission_mix_out = BSDF(vec3(0.0),vec3(1.0));\n            transmission_mix_out.response = mix(sheen_layer_out.response, transmission_bsdf_out.response, transmission);\n            transmission_mix_out.throughput = mix(sheen_layer_out.throughput, transmission_bsdf_out.throughput, transmission);\n            BSDF specular_layer_out = BSDF(vec3(0.0),vec3(1.0));\n            specular_layer_out.response = specular_bsdf_out.response + transmission_mix_out.response * specular_bsdf_out.throughput;\n            specular_layer_out.throughput = specular_bsdf_out.throughput * transmission_mix_out.throughput;\n            BSDF metalness_mix_out = BSDF(vec3(0.0),vec3(1.0));\n            metalness_mix_out.response = mix(specular_layer_out.response, metal_bsdf_out.response, metalness);\n            metalness_mix_out.throughput = mix(specular_layer_out.throughput, metal_bsdf_out.throughput, metalness);\n            vec3 thin_film_layer_attenuated_out_in2_clamped = clamp(coat_attenuation_out, 0.0, 1.0);\n            BSDF thin_film_layer_attenuated_out = BSDF(vec3(0.0),vec3(1.0));\n            thin_film_layer_attenuated_out.response = metalness_mix_out.response * thin_film_layer_attenuated_out_in2_clamped;\n            thin_film_layer_attenuated_out.throughput = metalness_mix_out.throughput * thin_film_layer_attenuated_out_in2_clamped;\n            BSDF coat_layer_out = BSDF(vec3(0.0),vec3(1.0));\n            coat_layer_out.response = coat_bsdf_out.response + thin_film_layer_attenuated_out.response * coat_bsdf_out.throughput;\n            coat_layer_out.throughput = coat_bsdf_out.throughput * thin_film_layer_attenuated_out.throughput;\n\n            shader_constructor_out.color += occlusion * coat_layer_out.response;\n        }\n\n        // Add surface emission\n        {\n            EDF emission_edf_out = EDF(0.0);\n            mx_uniform_edf(N, V, emission_weight_out, emission_edf_out);\n            EDF coat_tinted_emission_edf_out = emission_edf_out * coat_color;\n            EDF coat_emission_edf_out = EDF(0.0);\n            mx_generalized_schlick_edf(N, V, emission_color0_out, vec3(0.000000, 0.000000, 0.000000), 5.000000, coat_tinted_emission_edf_out, coat_emission_edf_out);\n            // Omitted node 'emission_edf'. Function already called in this scope.\n            EDF blended_coat_emission_edf_out = mix(emission_edf_out, coat_emission_edf_out, coat);\n            shader_constructor_out.color += blended_coat_emission_edf_out;\n        }\n\n        // Calculate the BSDF transmission for viewing direction\n        {\n            BSDF coat_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_dielectric_bsdf_transmission(V, coat, vec3(1.000000, 1.000000, 1.000000), coat_IOR, coat_roughness_vector_out, 0.000000, 1.500000, coat_normal, coat_tangent_out, 0, 0, coat_bsdf_out);\n            BSDF metal_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            BSDF specular_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_dielectric_bsdf_transmission(V, specular, specular_color, specular_IOR, main_roughness_out, thin_film_thickness, thin_film_IOR, normal, main_tangent_out, 0, 0, specular_bsdf_out);\n            BSDF transmission_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            mx_dielectric_bsdf_transmission(V, 1.000000, transmission_color, specular_IOR, transmission_roughness_out, 0.000000, 1.500000, normal, main_tangent_out, 0, 1, transmission_bsdf_out);\n            BSDF sheen_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            BSDF translucent_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            BSDF subsurface_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            BSDF selected_subsurface_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            selected_subsurface_bsdf_out.response = mix(subsurface_bsdf_out.response, translucent_bsdf_out.response, subsurface_selector_out);\n            selected_subsurface_bsdf_out.throughput = mix(subsurface_bsdf_out.throughput, translucent_bsdf_out.throughput, subsurface_selector_out);\n            BSDF diffuse_bsdf_out = BSDF(vec3(0.0),vec3(1.0));\n            BSDF subsurface_mix_out = BSDF(vec3(0.0),vec3(1.0));\n            subsurface_mix_out.response = mix(diffuse_bsdf_out.response, selected_subsurface_bsdf_out.response, subsurface);\n            subsurface_mix_out.throughput = mix(diffuse_bsdf_out.throughput, selected_subsurface_bsdf_out.throughput, subsurface);\n            BSDF sheen_layer_out = BSDF(vec3(0.0),vec3(1.0));\n            sheen_layer_out.response = sheen_bsdf_out.response + subsurface_mix_out.response * sheen_bsdf_out.throughput;\n            sheen_layer_out.throughput = sheen_bsdf_out.throughput * subsurface_mix_out.throughput;\n            BSDF transmission_mix_out = BSDF(vec3(0.0),vec3(1.0));\n            transmission_mix_out.response = mix(sheen_layer_out.response, transmission_bsdf_out.response, transmission);\n            transmission_mix_out.throughput = mix(sheen_layer_out.throughput, transmission_bsdf_out.throughput, transmission);\n            BSDF specular_layer_out = BSDF(vec3(0.0),vec3(1.0));\n            specular_layer_out.response = specular_bsdf_out.response + transmission_mix_out.response * specular_bsdf_out.throughput;\n            specular_layer_out.throughput = specular_bsdf_out.throughput * transmission_mix_out.throughput;\n            BSDF metalness_mix_out = BSDF(vec3(0.0),vec3(1.0));\n            metalness_mix_out.response = mix(specular_layer_out.response, metal_bsdf_out.response, metalness);\n            metalness_mix_out.throughput = mix(specular_layer_out.throughput, metal_bsdf_out.throughput, metalness);\n            vec3 thin_film_layer_attenuated_out_in2_clamped = clamp(coat_attenuation_out, 0.0, 1.0);\n            BSDF thin_film_layer_attenuated_out = BSDF(vec3(0.0),vec3(1.0));\n            thin_film_layer_attenuated_out.response = metalness_mix_out.response * thin_film_layer_attenuated_out_in2_clamped;\n            thin_film_layer_attenuated_out.throughput = metalness_mix_out.throughput * thin_film_layer_attenuated_out_in2_clamped;\n            BSDF coat_layer_out = BSDF(vec3(0.0),vec3(1.0));\n            coat_layer_out.response = coat_bsdf_out.response + thin_film_layer_attenuated_out.response * coat_bsdf_out.throughput;\n            coat_layer_out.throughput = coat_bsdf_out.throughput * thin_film_layer_attenuated_out.throughput;\n            shader_constructor_out.color += coat_layer_out.response;\n        }\n\n        // Compute and apply surface opacity\n        {\n            shader_constructor_out.color *= surfaceOpacity;\n            shader_constructor_out.transparency = mix(vec3(1.0), shader_constructor_out.transparency, surfaceOpacity);\n        }\n    }\n\n    out1 = shader_constructor_out;\n}\n\nvoid main()\n{\n    vec3 geomprop_Nworld_out = normalize(normalWorld);\n    vec3 geomprop_Tworld_out = normalize(tangentWorld);\n    surfaceshader SR_carpaint_out = surfaceshader(vec3(0.0),vec3(0.0));\n    NG_standard_surface_surfaceshader_100(base, base_color, diffuse_roughness, metalness, specular, specular_color, specular_roughness, specular_IOR, specular_anisotropy, specular_rotation, transmission, transmission_color, transmission_depth, transmission_scatter, transmission_scatter_anisotropy, transmission_dispersion, transmission_extra_roughness, subsurface, subsurface_color, subsurface_radius, subsurface_scale, subsurface_anisotropy, sheen, sheen_color, sheen_roughness, coat, coat_color, coat_roughness, coat_anisotropy, coat_rotation, coat_IOR, geomprop_Nworld_out, coat_affect_color, coat_affect_roughness, thin_film_thickness, thin_film_IOR, emission, emission_color, opacity, thin_walled, geomprop_Nworld_out, geomprop_Tworld_out, SR_carpaint_out);\n    out1 = vec4(mx_srgb_encode(SR_carpaint_out.color), 1.0);\n}\n\n",
    "transparent": false,
    "blendEquation": 100,
    "blendSrc": 205,
    "blendDst": 204,
    "side": 2
}